import pickle
import os
import time
import datetime
import angr
import colorama
from IPython import embed

class ExploitRoutineDFSMixin:
    def _smash(self, start_good_disclosure_state_idx):
        """
        try all candidate smash gadget
        :param start_good_disclosure_state_idx:
        :return:
        """
        for good_disclosure_state in self.good_disclosure_state[start_good_disclosure_state_idx:]:
            success = self.multiple_runs_smash_gadgets(good_disclosure_state)
            if success:  # at least we get a good smash state
                break
        return

    def _leak(self):
        """
        using the recent good bloom_fork_gadget to try leak current stack canary
        :return:
        """
        good_bloom_fork_pair = self.good_bloom_fork_gadget_pair[-1]
        number_of_old_good_disclosure_gadget = len(self.good_disclosure_state)
        # we will perform symbolic tracing to reach the first fork site
        print '[+] multiple runs bloom and fork gadget'
        bloom_gadget = good_bloom_fork_pair[0]
        forking_gadget = good_bloom_fork_pair[1]
        constraints = good_bloom_fork_pair[2]  # maybe remove this
        constraints_at_first_fork_site = good_bloom_fork_pair[3]
        history_bbl_addrs = good_bloom_fork_pair[4]
        first_reached_fork_site = good_bloom_fork_pair[5]
        self.current_bloom_gadget = bloom_gadget  # set current bloom gadget
        self.current_forking_gadget = forking_gadget  # set current_forking_gadget
        self.current_firstly_reached_fork_site = first_reached_fork_site
        initial_state = self.initial_state

        if first_reached_fork_site in [1, 3]:
            print 'firstly reach first fork site'
        elif first_reached_fork_site in [2, 4]:
            print 'firstly reach second fork site'
        else:
            assert 0
        self.tmp_good_disclosure_state_number = 0
        fork_site_state = None
        trial_number = 0

        # keep trying symbolic tracing to reach the first fork site
        while fork_site_state is None and trial_number < 15:
            tmp_state = initial_state.copy()
            # perform symbolic tracing now
            fork_site_state = self.run_symbolic_tracing_to_first_fork_site(tmp_state, bloom_gadget,
                                forking_gadget, history_bbl_addrs,
                                first_constraint_func=self.first_constraint_func)
            del tmp_state
            trial_number += 1
        if fork_site_state is None:  # did not reach the fork site
            print('failed symbolic tracing attempt')
            if self.debug_dfs:
                embed()
            return
        print 'finished symbolic tracing'
        for i, prologue_disclosure_pair in enumerate(self.prologue_disclosure_pairs):
            print '====== checking %d/%d pair of prologue and disclosure gadget' % (i,
                                                                                    len(self.prologue_disclosure_pairs))
            #if i < 600:  # debug only
                #continue  # debug only
            tmp_state = fork_site_state.copy()
            prologue_gadget = prologue_disclosure_pair[0]
            prologue_entry = prologue_gadget[6]
            # constrain first fork site to the entry of prologue function and checks satisfiability.
            tmp_state.add_constraints(tmp_state.regs.rip == prologue_entry)
            if not tmp_state.satisfiable():
                print '[+] can not constrain rip to this prologue gadget', prologue_gadget
                continue
            self.run_prologue_and_disclosure_gadget(tmp_state, bloom_gadget, forking_gadget, prologue_disclosure_pair
                                                    , first_reached_fork_site, first_constraint_func=None)
            # check whether we found leak state
            if number_of_old_good_disclosure_gadget < len(self.good_disclosure_state):  # found new disclosure state
                print '[+] found new good disclosure gadget, try smashing :)'

                # continue and do smash
                self._smash(number_of_old_good_disclosure_gadget)

                number_of_old_good_disclosure_gadget = len(self.good_disclosure_state)  # update number of good gadget
            del tmp_state

        del fork_site_state

        return

    def _fork(self, start_fork_idx=0, end_fork_idx=-1):
        good_bloom_gadget = self.good_bloom_gadget[-1]
        print '[+] multiple runs forking gadget'
        bloom_gadget = good_bloom_gadget[0]
        bloom_state = good_bloom_gadget[1]
        self.current_bloom_gadget = bloom_gadget
        total = len(self.fork_gadgets)
        if end_fork_idx == -1:
            end_fork_idx = total
        for i, forking_gadget in enumerate(self.fork_gadgets):
            print '[+] ===== checking %d/%d th forking gadget...=====' % (i, total)
            print forking_gadget
            if i < start_fork_idx:
                print 'skip this fork gadget'
                continue
            if i >= end_fork_idx:
                print 'skip this fork gadget'
                continue
            tmp_state = bloom_state.copy()
            old_number_of_good_bloom_fork_gadget_pair = len(self.good_bloom_fork_gadget_pair)
            self.run_forking_gadget(tmp_state, good_bloom_gadget, forking_gadget)  # run fork gadget
            fork_entry, first_fork_site, second_fork_site = self.get_forking_gadget_entry_and_sites(forking_gadget)
            # remove hook at forking site
            self.b.unhook(first_fork_site)
            self.b.unhook(second_fork_site)
            del tmp_state
            new_number_of_good_bloom_fork_gadget_pair = len(self.good_bloom_fork_gadget_pair)
            if old_number_of_good_bloom_fork_gadget_pair != new_number_of_good_bloom_fork_gadget_pair:  # found fork gadgets
                self._leak()

        return

    def _bloom(self, start_bloom_idx, only_once=False, start_fork_idx=0, end_fork_idx=-1):
        # get initial state
        initial_state = self.get_initial_state(switch_cpu=True,
                                               control_memory_base=self.controlled_memory_base,
                                               control_memory_size=self.controlled_memory_size)
        self.initial_state = initial_state
        if self.pause_on_init_state:
            embed()
        total = len(self.bloom_gadgets)
        for i, bloom_gadget in enumerate(self.bloom_gadgets):
            print '[+] ===== checking %d/%d th bloom gadget: ' % (i, total) + bloom_gadget[1] + '... ====='
            if only_once:
                if i != start_bloom_idx:
                    continue
                else:
                    self.draw_progress_bar(i, total)
            else:
                if i < start_bloom_idx:
                    continue
                else:
                    self.draw_progress_bar(i, total)
            # some function should be put in blacklist
            if bloom_gadget[1] == 'udp_v6_early_demux':
                continue
            tmp_state = initial_state.copy()
            seen_bloom_state = self.run_bloom_gadget(tmp_state, bloom_gadget, first_constraint_func=self.first_constraint_func)
            del tmp_state
            if seen_bloom_state:  # has found bloom state
                self._fork(start_fork_idx=start_fork_idx, end_fork_idx=end_fork_idx)  # do fork state
        return

    def _bloom_multiple_threads(self, start_bloom_idx):
        """
        This function is still under construction
        :param start_bloom_idx:
        :return:
        """
        initial_state = self.get_initial_state(switch_cpu=True,
                                               control_memory_base=self.controlled_memory_base,
                                               control_memory_size=self.controlled_memory_size)
        self.initial_state = initial_state
        if self.pause_on_init_state:
            embed()
        total = len(self.bloom_gadgets)
        for i, bloom_gadget in enumerate(self.bloom_gadgets):
            print '[+] ===== checking %d/%d th bloom gadget: ' % (i, total) + bloom_gadget[1] + '... ====='
            self.draw_progress_bar(i, total)
            if i < start_bloom_idx:
                continue
            # some function should be put in blacklist
            if bloom_gadget[1] == 'udp_v6_early_demux':
                continue
            tmp_state = initial_state.copy()
            seen_bloom_state = self.run_bloom_gadget(tmp_state, bloom_gadget, first_constraint_func=self.first_constraint_func)
            del tmp_state
            if seen_bloom_state:  # has found bloom states
                self._fork()  # do fork state
        return

    def doit_dfs(self, use_qemu_snapshot=False, start_bloom_idx=0, debug_dfs=False, multiple_process=False):
        self.prologue_disclosure_pairs = self.get_prologue_disclosure_pairs()
        self.is_dfs_search_routine = True
        self.debug_dfs=debug_dfs
        self.use_qemu_snapshot = use_qemu_snapshot
        self.start_bloom_idx = start_bloom_idx
        if not use_qemu_snapshot:
            print '[+] taking snapshot'
            self.dump_hyper_parameters()
            self.take_qemu_snapshot()
            print 'finished taking snapshot'
        else:
            # init state
            self.load_hyper_parameters()
            self.load_qemu_snapshot()

            # start dfs search for exploit chains
            if multiple_process:
                self._bloom_multiple_threads(start_bloom_idx)
            else:
                self._bloom(start_bloom_idx)
        return

    def doit_dfs_once(self, use_qemu_snapshot=False, start_bloom_idx=0, debug_dfs=False,
                      start_fork_idx=0, end_fork_idx=-1):
        self.prologue_disclosure_pairs = self.get_prologue_disclosure_pairs()
        self.is_dfs_search_routine = True
        self.debug_dfs = debug_dfs
        self.use_qemu_snapshot = use_qemu_snapshot
        self.start_bloom_idx = start_bloom_idx
        if not use_qemu_snapshot:
            print '[+] taking snapshot'
            self.dump_hyper_parameters()
            self.take_qemu_snapshot()
            print 'finished taking snapshot'
        else:
            # init state
            self.load_hyper_parameters()
            self.load_qemu_snapshot()

            # start dfs search for exploit chains
            self._bloom(start_bloom_idx, only_once=True, start_fork_idx=start_fork_idx, end_fork_idx=end_fork_idx)
        return
